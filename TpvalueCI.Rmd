---
title: "KS_pvalue"
author: "xzh"
date: "10/07/2019"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
f = function(x){
  return(dnorm(x,mean=0,sd=1))
}
g = function(x){
  return(dnorm(x,mean=0.5,sd=1))
}

# index: the affected censor, K: the number of all the censors
generateN = function(mu,size=100){
  column = rnorm(size,mean=mu,sd=1)
  return(as.matrix(column))
}

# n = number of infected censor, K = Number of Censor
simulate_topr = function(n,mug=0.5,r=10,a=46.55){
  mu = c(rep(mug,n),rep(0,100-n))
  W = rep(0,100)
  m = 0
  data = c()
  allW = c()
  while (TRUE) {
    m = m + 1
    data=cbind(data,generateN(mu))
    W = W + log(g(data[,m])/f(data[,m]))
    W = ifelse(W>0,W,0)
    allW = cbind(allW,W)
    
    s = sort(W,decreasing = TRUE,index.return =TRUE)
    w = s$x[1:r]
    r.index = s$ix[1:r]
    
    t = sum(w)
    if (t > a){
      break
    }
  }
  
  T0 = apply(data,1,mean)/(1/sqrt(m))
  # data: the whole dataset, n: stopping time, 
  # W: the vector of all the W statistic, r.index: selected index
  result <- list(data=data,StopT=m,W=W,allW=allW,T0=T0,r.index = r.index,sig=n,mug=mug)
  return(result)
}

# t = Stopping time T, K = Number of censor
simulate_topr_GlobalNullT = function(t,mu,r=10,a=46.55){
  W = rep(0,100)
  m = 0
  
  data = matrix(generateN(mu,size=100*t),nrow=100,byrow=FALSE)
  
  while (m < t){
    m = m + 1
    # 
    # if (m %% 50 == 0) {
    #   data=cbind(data,matrix(generateN(mu,size=100*50),nrow=100,byrow=FALSE))
    # }
    
    W = W + log(g(data[,m])/f(data[,m]))
    W = ifelse(W>0,W,0)
    
    s = sort(W,decreasing = TRUE,index.return =TRUE)
    w = s$x[1:r]
    r.index = s$ix[1:r]
    
    t0 = sum(w)
    if (t0 > a){
      break
    }
  }
  
  T0 = apply(data,1,mean)/(1/sqrt(m))
  
  result <- list(data=data,eStop=m,n=t0,W=W,T0=T0,r.index = r.index)
  return(result)
}


simulate_topr_GlobalNullT_BT = function(topr,mu,rejIndex,tindex,r=10,B = 500,a = 46.55){
  indicator = c()
  for (i in 1:B){
    Tr = simulate_topr_GlobalNullT(topr$StopT,mu, r = 10, a = 46.55)
    index = Tr$r.index[which(Tr$r.index %in% rejIndex==FALSE)]
    T0 = Tr$T0[index]
    
    indicator = c(indicator, ifelse(T0>topr$T0[tindex],1,0))
  }
  return(indicator)
}

simulate_topr_KnockoffGlobalNull_BT = function(topr,mu,rejIndex,tindex,r=10,B = 500,a = 46.55){
  indicator = c()
  for (i in 1:B){
    Tr = simulate_topr_GlobalNullT(topr$StopT,mu, r = 10, a = 46.55)
    index = Tr$r.index[which(Tr$r.index %in% rejIndex==FALSE)]
    T_ = Tr$T0[index]
    T0 = matrix(rep(T_,length(tindex)),length(tindex),byrow = TRUE)
    ind = ifelse(T0 > topr$T0[tindex],1,0)
    indicator = cbind(indicator, ind)
  }
  return(indicator)
}
```


```{r}
# t = Stopping time T, K = Number of censor
simulate_topr_GlobalNullT_Stepdown = function(t,K,ObsW,rindex,r=10,a=46.55){
  W = rep(0,K)
  m = 0
  # data = c()
  r = r - (100-K)
  ObsW = ObsW[rindex,]
  mu = rep(0,100)
  
  data = matrix(generateN(mu,size=K*t),nrow=K,byrow=FALSE)
  
  for (i in 1:t){
    m = m + 1
    # data=cbind(data,generateN(mu)[1:K])
    W = W + log(g(data[,m])/f(data[,m]))
    W = ifelse(W>0,W,0)
    w = sort(W,decreasing = TRUE)[1:r]
    if (is.null(rindex)){
      t0 = sum(w)
    } else if (length(rindex)==1){
      t0 = sum(w)+ObsW[t]
    } else {
      t0 = sum(w)+sum(ObsW[,t])
    }
    
    if (t0 > a){
      break
    }
  }
  result <- list(W=w,StopT=i)
  return(result)
}


simulate_topr_GlobalNullT_B_Stepdown = function(topr,rindex,tindex,B = 200,K = 100,a = 46.55){
  indicator = c()
  for (i in 1:B){
    s = simulate_topr_GlobalNullT_Stepdown(t=topr$StopT,ObsW=topr$allW,rindex=rindex,K = K, r = 10, a = 46.55)
    # print(s$StopT)
    indicator = c(indicator, ifelse(s$W>topr$allW[tindex,s$StopT],1,0))
  }
  return(indicator)
}
```





```{r}
knockoff = function(topr,q0){
  muNull = rep(0,100)
  null = simulate_topr_GlobalNullT(topr$StopT,mu=muNull,r=10,a=46.55)
  
  W = topr$W - null$W
  for (t in seq(0,10,0.01)){
    Spt = sum(W> t)
    Smt = sum(W<(-t))
    q = (1 + Smt)/Spt
    if (q <= q0){
      break
    } else if (t == 10){
      t = 1000
    }
  }
  
  reject_index = which(W > t)
  return(reject_index)
}

```

```{r}
Stepdown = function(topr,q=0.2){
  rindex = c()
  K0 = 100
  q = 0.2
  pvalue = c()
  for (i in topr$r.index){
    # print(rindex)
    ind = simulate_topr_GlobalNullT_B_Stepdown(topr,rindex=rindex,i,K=K0)
    p = sum(ind)/length(ind)
    pvalue = c(pvalue,p)
    if (p <= q/(K0-90)){
      K0 = K0-1
      rindex = c(rindex,i)
    } else{
      break
    }
  }
  # pvalue = cbind(topr$r.index,pvalue)
  # fdr = sum((pvalue[,2]<q)&(pvalue[,1] %in% seq(1,sig) == FALSE))/sum(pvalue[,2]<q)
  # power = sum((pvalue[,2]<q)&(pvalue[,1] %in% seq(1,sig)))/sig
  
  result = list(p=pvalue,rindex=rindex)
  return(result)
}
```



```{r}
knockoffAcp = function(topr){
  q = 0.2
  rejIndex0 = knockoff(topr,q0=0.2)
  rejIndex1 = Stepdown(topr)$rindex
  rejIndex = union(rejIndex0,rejIndex1)
  
  if (length(rejIndex)==1){
    muHat = mean(topr$data[rejIndex,])
  } else{
    muHat = apply(topr$data[rejIndex,],1,mean)
  }
  mu = rep(0,100)
  mu[rejIndex] = muHat
  
  rejT = intersect(topr$r.index,rejIndex)

  p=c()
  for (i in rejT){
    mu0 = mu
    mu0[i] = 0
    ind = simulate_topr_KnockoffGlobalNull_BT(topr,mu0,rejIndex,tindex=i)
    p = rbind(p,c(i,sum(ind)/length(ind)))
  }
  
  tindex = setdiff(topr$r.index,rejT)
  ind = simulate_topr_KnockoffGlobalNull_BT(topr,mu,rejIndex,tindex=tindex)
  p0 = cbind(tindex,apply(ind,1,sum)/dim(ind)[2])
  p = rbind(p,p0)
  # p = p[sort(p[,2],index.return=TRUE)$ix,]
  p=cbind(p,p.adjust(p[,2],method="BH"))
  p = cbind(p,apply(topr$data[topr$r.index,],1,mean))
  p = cbind(p,topr$W[topr$r.index])
  
  fdr01 = sum((p[,3]<0.1)&(p[,1] %in% seq(1,sig) == FALSE))/sum(p[,3]<0.1)
  power01 = sum((p[,3]<0.1)&(p[,1] %in% seq(1,sig)))/sig
  
  fdr02 = sum((p[,3]<0.2)&(p[,1] %in% seq(1,sig) == FALSE))/sum(p[,3]<0.2)
  power02 = sum((p[,3]<0.2)&(p[,1] %in% seq(1,sig)))/sig
  
  result = list(p=p,fdr01=fdr01,power01=power01,fdr02=fdr02,power02=power02)
  return(result)
}
```


```{r}
library(tcltk2) 
FDR01=c()
POWER01=c()
FDR02=c()
POWER02=c()

pb <- tkProgressBar("进度","已完成 %", 0, 100)
size = 50
sig=10
for (i in 1:size){
  topr = simulate_topr(n=sig)
  KA = knockoffAcp(topr)
  FDR01 = c(FDR01,KA$fdr01)
  POWER01 = c(POWER01,KA$power01)
  
  FDR02 = c(FDR02,KA$fdr02)
  POWER02 = c(POWER02,KA$power02)
  
  info<- sprintf("已完成 %d%%", round(i*100/size))  
  setTkProgressBar(pb, i*100/size, sprintf("进度 (%s)", info),info)
}
close(pb)
```


```{r}
FDR01[is.nan(FDR01)] = 0
mean(FDR01)
mean(POWER01)
FWER01 = sum(FDR01>0)/length(FDR01)
FWER01
```



```{r}
FDR02[is.nan(FDR02)] = 0
mean(FDR02)
mean(POWER02)
FWER02 = sum(FDR02>0)/length(FDR02)
FWER02
```


  | # affected | $\mu_g$ |  $q$  |  FDR  |  POWER  | FWER  |
  | :--------: | :-----: | :---: | :---: | :-----: | :---: |
  |      1     |   0.5   |  0.1  | 0.182 |  1      | 0.34  |
  |      1     |   0.5   |  0.2  | 0.355 |  1      | 0.62  |
  |      5     |   0.5   |  0.1  | 0.083 |  0.768  | 0.32  |
  |      5     |   0.5   |  0.2  | 0.153 |  0.852  | 0.58  |
  |      10    |   0.5   |  0.1  | 0.072 |  0.524  | 0.32  |
  |      10    |   0.5   |  0.2  | 0.141 |  0.606  | 0.64  |
  |      20    |   0.5   |  0.1  |
  |      20    |   0.5   |  0.2  |
  
  
  
  
  

```{r}
# t = Stopping time T, K = Number of censor
simulate_topr_CI = function(mu,t,r=10,a=46.55){
  W = rep(0,100)
  m = 0
  # data = c()
  data = matrix(generateN(mu,size=100*50),nrow=100,byrow=FALSE)
  
  while(TRUE){
  # for (i in 1:t){
    m = m + 1
    if (m %% 50 == 0) {
      data=cbind(data,matrix(generateN(mu,size=100*50),nrow=100,byrow=FALSE))
    }
    
    W = W + log(g(data[,m])/f(data[,m]))
    W = ifelse(W>0,W,0)
    
    s = sort(W,decreasing = TRUE,index.return =TRUE)
    w = s$x[1:r]
    r.index = s$ix[1:r]
    
    t0 = sum(w)
    if (t0 > a){
      break
    }
  }
  Xbar = apply(data,1,mean)
  result <- list(data=data,StopTb=m,W=W,r.index = r.index,Xbar = Xbar)
  return(result)
}
```



  
```{r}
computeF = function(topr,theta,mu,tindex,alpha){
  R = (mean(topr$data[tindex,])-theta)/(sd(topr$data[tindex,])/sqrt(topr$StopT))
  mu[tindex] = theta
  Ri = c()
  i = 1
  while (i <= 200){
    Xi = simulate_topr_CI(mu,t=topr$StopT)
    if (tindex%in%Xi$r.index==FALSE){
      next
    }
    ri = (Xi$Xbar[tindex]-theta)/(1/sqrt(Xi$StopTb))
    # print(i)
    # print(mu[Xi$r.index])
    # if (mu[tindex] %in% mu[Xi$r.index] ==FALSE){
    #   next
    # }
    i = i+1
    Ri = c(Ri,ri)
  }
  Ri = sort(Ri)
  muL = Ri[200*(1-alpha)]
  return(R - muL)
}
```

```{r}
CI = function(topr,tindex,mu,q){
  theta = 100
  a = mean(topr$data[tindex,]) ##<0
  fa = computeF(topr,theta=a,mu=mu,tindex,alpha=q)
  b = a - 2*1/sqrt(topr$StopT)
  fb = computeF(topr,theta=b,mu=mu,tindex,alpha=q)
  while (TRUE){
    if (fb<=0){
      # print(b)
      b = b - 0.5*1/sqrt(topr$StopT)
      if (b<=0){
        return(0)
      }
      fb = computeF(topr,theta=b,mu=mu,tindex,alpha=q)
    } else{
      break
    }
  }
  
  oldTheta = theta
  theta = (b*fa - a*fb)/(fa-fb)
  k=1
  while ((abs(theta-oldTheta)>=0.01)&(k<=10)){
    f0 = computeF(topr,theta=theta,mu=mu,tindex,alpha=q)
    if (f0<0){
      a = theta
      fa = f0
    }else{
      b = theta
      fb = f0
    }
    oldTheta = theta
    theta = (b*fa - a*fb)/(fa-fb)
    k = k+1
  }
  return(theta)
}
```




```{r}
knockoffAcpCI = function(topr,q){
  rejIndex0 = knockoff(topr,q0=0.2)
  rejIndex1 = Stepdown(topr,q)$rindex
  rejIndex = union(rejIndex0,rejIndex1)
  
  if (length(rejIndex)==1){
    muHat = mean(topr$data[rejIndex,])
  } else{
    muHat = apply(topr$data[rejIndex,],1,mean)
  }
  mu = rep(0,100)
  mu[rejIndex] = muHat
  
  rejT = intersect(topr$r.index,rejIndex)

  p=c()
  for (i in rejT){
    mu0 = mu
    mu0[i] = 0
    ind = simulate_topr_KnockoffGlobalNull_BT(topr,mu0,rejIndex,tindex=i)
    p = rbind(p,c(i,sum(ind)/length(ind)))
  }
  
  tindex = setdiff(topr$r.index,rejT)
  ind = simulate_topr_KnockoffGlobalNull_BT(topr,mu,rejIndex,tindex=tindex)
  p0 = cbind(tindex,apply(ind,1,sum)/dim(ind)[2])
  p = rbind(p,p0)
  p=cbind(p,p.adjust(p[,2],method="BH"))
  
  LB = c()
  for (i in topr$r.index){
    if (p[p[,1]==i][2]>q){
      lb = 0
    } else{
      mu0 = mu
      mu0[i] = 0
      lb = CI(topr,tindex = i,mu=mu0,q)
    }
    LB = c(LB,lb)
  }
  
  p = cbind(p,LB)
  mu = c(rep(topr$mug,topr$sig),rep(0,100-topr$sig))
  p = cbind(p,mu[topr$r.index])
  p = cbind(p,apply(topr$data[topr$r.index,],1,mean))
  colnames(p) = c("index","p-value","p-valueBH","CILowerBond","trueMu","muHat")
  return(p)
}
```

 | # affected | $\mu_g$ |  $q$  |   CR  |
 | :--------: | :-----: | :---: | :---: |
 |     20     |   0.5   |  0.1  | 0.603 |
 |     20     |   0.5   |  0.2  | 0.473 |
 |     10     |   0.5   |  0.1  | 0.791 |
 |     10     |   0.5   |  0.2  | 0.636 |
 |     5      |   0.5   |  0.1  | 0.829 |
 |     5      |   0.5   |  0.2  | 0.733 |
 |     1      |   0.5   |  0.1  | 
 |     1      |   0.5   |  0.2  | 


```{r}
library(tcltk2) 
pb <- tkProgressBar("进度","已完成 %", 0, 100)
size = 100

CR = c()
for (i in 1:size){
  topr = simulate_topr(n=5,mug=0.5)
  p = knockoffAcpCI(topr,q=0.2)
  cr = ifelse(p[,5]>=p[,4],1,0)
  CR = c(CR,cr)
  
  info<- sprintf("已完成 %d%%", round(i*100/size))  
  setTkProgressBar(pb, i*100/size, sprintf("进度 (%s)", info),info)
}
close(pb)
```

```{r}
mean(CR)
```



```{r}
library(tcltk2) 
pb <- tkProgressBar("进度","已完成 %", 0, 100)
size = 100

CR = c()
for (i in 1:size){
  topr = simulate_topr(n=20,mug=0.5)
  p = knockoffAcpCI(topr,q=0.1)
  cr = ifelse(p[,5]>=p[,4],1,0)
  CR = c(CR,cr)
  
  info<- sprintf("已完成 %d%%", round(i*100/size))  
  setTkProgressBar(pb, i*100/size, sprintf("进度 (%s)", info),info)
}
close(pb)
```

```{r}
mean(CR)
```




```{r}
library(tcltk2) 
pb <- tkProgressBar("进度","已完成 %", 0, 100)
size = 100

CR = c()
for (i in 1:size){
  topr = simulate_topr(n=20,mug=0.5)
  p = knockoffAcpCI(topr,q=0.2)
  cr = ifelse(p[,5]>=p[,4],1,0)
  CR = c(CR,cr)
  
  info<- sprintf("已完成 %d%%", round(i*100/size))  
  setTkProgressBar(pb, i*100/size, sprintf("进度 (%s)", info),info)
}
close(pb)
```

```{r}
mean(CR)
```